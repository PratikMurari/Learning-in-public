SECTION 6: DON'T USE `any`
==========================

1) What is `any`?
-----------------
- `any` is a **special marker type** in TypeScript.
- It tells the compiler: "Don‚Äôt check this variable‚Äôs type. Let it be *anything*."
- Effectively turns off TypeScript‚Äôs safety ‚Üí defeats the purpose of using TS.

‚ö†Ô∏è Using `any` too much makes your code just like plain JavaScript.

2) Why Developers Use It (and Why It‚Äôs Bad)
-------------------------------------------
- When they don‚Äôt know what type a variable will have.
- Example: data coming from an API or a function without a defined return type.
- Problem: `any` allows wrong data (e.g., string, boolean, number) to silently pass, breaking consistency.

3) Example of `any` in Action
-----------------------------

*** Example.ts ***
let hero;   // no type ‚Üí inferred as 'any'

function getHero() {
  return "Thor";  // returns a string
}

hero = getHero();  // type is 'any'

// Later: another dev changes the function
function getHero() {
  return true;    // returns a boolean
}

hero = getHero(); // still allowed ‚ùå
console.log(hero);  // true (unexpected)
*** /Example.ts ***

üí° Problem ‚Üí TS didn‚Äôt catch the mistake because type checking was disabled with `any`.

4) The Right Way
----------------
- Explicitly type your variables or functions.

*** Example.ts ***
function getHero(): string {
  return "Thor";
}

let hero: string = getHero();   // ‚úÖ ensures only string
*** /Example.ts ***

- Now if someone tries to return a boolean:

*** Example.ts ***
function getHero(): string {
  return true;   // ‚ùå Error: boolean is not assignable to string
}
*** /Example.ts ***

5) Key Docs Notes
-----------------
- `any` means **turn off type checking**.
- Official TS docs: ‚ÄúAvoid using `any` as much as possible.‚Äù
- Use `noImplicitAny` flag in `tsconfig.json` to prevent accidental `any`.

*** Example (tsconfig.json) ***
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true
  }
}
*** /Example ***

6) When `any` *might* be okay
-----------------------------
- Very rare cases: quick prototyping, working with legacy JS libraries that don‚Äôt have type definitions.
- Even then ‚Üí better alternatives exist:  
  - Use `unknown` (forces you to check the type before using).  
  - Use proper type definitions (`@types/` packages).  

7) Modern Best Practices (TS 5+)
--------------------------------
- Prefer `unknown` instead of `any` when the type is unclear.  
- Use union types or generics if a value can be multiple types.  
- Libraries are much better typed now ‚Äî don‚Äôt default to `any`.

8) Recap Code
-------------
*** Example.ts ***
// Bad ‚ùå
let data: any;
data = 42;
data = "hello";
data = true;

// Better ‚úÖ
let hero: string = "Thor";

function getHero(): string {
  return "Iron Man";
}

// Even safer: unknown forces checks
let value: unknown = "Hello";
if (typeof value === "string") {
  console.log(value.toUpperCase());
}
*** /Example.ts ***

PRACTICE TASK
-------------
1. Create a function `getUserId` that should always return a `number`.
   - Try returning a string ‚Üí see TS error.
2. Create a variable with type `any` and assign:
   - a string
   - a number
   - a boolean  
   ‚Üí Notice TS doesn‚Äôt complain.
3. Rewrite it using `unknown`.  
   - Try to use the variable directly ‚Üí see error.  
   - Add a type check (`typeof`) before using it.
4. Enable `"noImplicitAny": true` in your `tsconfig.json` and test how TS flags missing types.

KEY TAKEAWAY
------------
Avoid `any`. It cancels out TypeScript‚Äôs main benefit (type safety).  
Prefer `unknown`, explicit types, or union types for flexibility with safety.
